<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, defaultSliderValue-scale=1.0">
  <title>法務省登記所備付地図データ 公共座標の筆かつ所属する市区町村外の座標を可視化</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">
  <link rel="stylesheet" href="./style.css">
  <script src="https://kit.fontawesome.com/5a581d1c6f.js" crossorigin="anonymous"></script>
</head>

<body>
  <div id="map" class="left" data-zoom="5" data-lat="37.01" data-lng="138.09" data-hash="on" data-marker="off" data-gesture-handling="off"></div>
  <div class="map-overlay-container">
    <div class="map-overlay top">
      <div class="map-overlay-inner">
        <h2 class="h5">座標が不正確な<br/>地図XMLファイルを可視化</h2>
        <div>地図XMLファイルの件数: <span id="outside-area-count"></span></div>
        <label>市区町村外の面積の割合 <span id="outside-area"></span></label>
        <input id="slider" type="range" min="1" max="100" step="1" value="50">
        <div class="legend-container">
          <div id="legend-number">
            <div>0%</div>
            <div>50%</div>
            <div>100%</div>
          </div>
        </div>
        <a id="download"><button id="download_btn" type="button" class="btn btn-primary btn-lg btn-block"></button></a>
        <a class="attribution" href="https://front.geospatial.jp/houmu-chiseki/" target="_blank"
          rel="noopener noreferrer">
          <p>「登記所備付データ」（法務省）を加工して作成</p>
        </a>
      </div>
    </div>
  </div>
  <script src="https://cdn.geolonia.com/v1/embed?geolonia-api-key=YOUR-API-KEY"></script>
  <script>

    const defaultSliderValue = 50
    const exportCSVHeader = ['xml_file', 'outside_area_rate']
    const layers = [
      'outside-area/polygonFill',
      'outside-area/polygonBorder',
      'outside-area/polygonNameCity',
    ];
    const clusterLayers = [
      'outside-area/cluster',
      'outside-area/cluster-count',
      'outside-area/unclustered-point',
    ]

    const fetchCSV = async (url) => {
      const response = await fetch(url);
      let text = await response.text();
      text = text.replace(/^.+\n/, '');

      const rows = text.split('\n').map((row) => {
        const columns = row.split(',');
        return columns;
      });
      return rows;
    }

    const convertArrayOfObjectsToCSV = (array) => {
      let result, columnDelimiter, lineDelimiter, data

      if (array == null || !array.length) {
        return null
      }

      columnDelimiter = ','
      lineDelimiter = '\n'

      data = typeof array !== 'object' ? JSON.parse(array) : array

      result = ''
      result += exportCSVHeader.join(columnDelimiter)
      result += lineDelimiter

      data.forEach(function (items) {
        let ctr = 0
        items.forEach(function (item) {
          
          if (item.endsWith('.zip')) {
            item = item.replace(/\.zip$/, '.xml')
          }

          if (ctr > 0) result += columnDelimiter

          result += item
          ctr++
        })
        result += lineDelimiter
      })

      return result
    }

    const downloadCSV = (csv, areaRate) => {
      const csvFile = new Blob([csv], { type: 'text/csv' })
      const filename = `outside_area_${areaRate}.csv`
      const label = '>= ' + areaRate

      const downloadLink = document.getElementById('download')
      downloadLink.download = filename
      downloadLink.href = window.URL.createObjectURL(csvFile)

      const downloadBtn = document.getElementById('download_btn')
      downloadBtn.innerHTML = `<i class="fa-solid fa-download"></i>地図XMLファイル一覧を<br/>CSVでダウンロード(${label}%)`
      downloadBtn.style.display = 'block'
    }

    const filterOutSideArea = (outsideAreaList, selectedOutSideRate) => {

      if (selectedOutSideRate === 0) {
        return [[]]
      }

      return outsideAreaList.filter((row) => {
        return Number(row[1]) >= selectedOutSideRate / 100;
      });
    }

    const setOutSideAreaCount = (outsideAreaList, selectedOutSideRate) => {

      if (selectedOutSideRate === 0) {
        document.getElementById("outside-area-count").textContent = `-- 件`;
        return;
      }

      document.getElementById("outside-area-count").textContent = `${(outsideAreaList.length).toLocaleString()}件`;
    }

    const filterBy = (selectedOutSideRate, data) => {

      const allLayers = [...layers, ...clusterLayers];

      if (selectedOutSideRate === 0) {

        allLayers.forEach((layer) => {
          map.setLayoutProperty(layer, 'visibility', 'none');
        });
        

      } else {
        const filters = [">=", ["to-number", ["get", "outside_area_rate"]], selectedOutSideRate / 100];

        layers.forEach((layer) => {
          map.setFilter(layer, filters);
        });

        allLayers.forEach((layer) => {
          map.setLayoutProperty(layer, 'visibility', 'visible');
        });

        const newGeoJSON = {
          type: 'FeatureCollection',
          features: []
        };
        const newFeatures = [...data.features]
        newGeoJSON.features = newFeatures.filter((feature) => {
          return feature.properties.outside_area_rate >= selectedOutSideRate / 100;
        });

        map.getSource('outside-area-cluster').setData(newGeoJSON);
      }
      
      document.getElementById("outside-area").textContent = `>= ${selectedOutSideRate}%`;
    }

    const map = new geolonia.Map({
      container: "#map",
      style: "./style.json"
    });

    map.on('load', async () => {

      const response = await fetch(
        'https://geolonia.github.io/chiban-kokyozahyo-area/outside-area-cluster.geojson'
      );
      const data = await response.json();

      map.addSource('outside-area-cluster', { 
        type: 'geojson', 
        data: data,
        cluster: true,
        clusterMaxZoom: 11,
        clusterRadius: 50
      });

      map.addLayer({
        "id": "outside-area/cluster",
        "type": "circle",
        "source": "outside-area-cluster",
        "filter": [
          "has",
          "point_count"
        ],
        "paint": {
          "circle-color": "#0000ff",
          "circle-radius": [
            "step",
            [
              "get",
              "point_count"
            ],
            20,
            100,
            30,
            750,
            40
          ]
        }
      })

      map.addLayer({
        "id": "outside-area/cluster-count",
        "type": "symbol",
        "source": "outside-area-cluster",
        "filter": [
          "has",
          "point_count"
        ],
        "layout": {
          "text-field": "{point_count_abbreviated}",
          "text-font": [
            "Noto Sans CJK JP Bold"
          ],
          "text-size": 14
        },
        "paint": {
          "text-color": "#fff"
        }
      })

      map.addLayer({
        "id": "outside-area/unclustered-point",
        "type": "circle",
        "source": "outside-area-cluster",
        "maxzoom": 11,
        "filter": [
          "!",
          [
            "has",
            "point_count"
          ]
        ],
        "paint": {
          "circle-color": "#0000ff",
          "circle-radius": 4,
          "circle-stroke-width": 1,
          "circle-stroke-color": "#fff"
        }
      });

      layers.forEach((layer) => {
        map.setLayoutProperty(layer, 'visibility', 'visible');
      });

      map.on('click', 'outside-area/cluster', (e) => {
        const features = map.queryRenderedFeatures(e.point, {
          layers: ['outside-area/cluster']
        });
        const clusterId = features[0].properties.cluster_id;
        map.getSource('outside-area-cluster').getClusterExpansionZoom(
          clusterId,
          (err, zoom) => {
            if (err) return;

            map.easeTo({
              center: features[0].geometry.coordinates,
              zoom: zoom
            });
          }
        );
      });

      map.on('mouseenter', 'outside-area/cluster', () => {
        map.getCanvas().style.cursor = 'pointer';
      });
      map.on('mouseleave', 'outside-area/cluster', () => {
        map.getCanvas().style.cursor = '';
      });

      map.on('click', 'outside-area/polygonFill', (e) => {

        const properties = e.features[0].properties;

        let tableHTML = '';
        for (const key in properties) {
          let label = key;
          let value = properties[key];

          if (label === 'outside_area_rate') {
            label = '市区町村外の面積<br/>（割合）'
            value = `${value * 100}%`
          }

          if (label === 'zip_file') {
            label = 'XMLファイル名'
            value = `${value}.xml`
          }

          tableHTML += `<tr><th>${label}</th><td>${value}</td></tr>`;
        }

        const popup = new geolonia.Popup()
          .setLngLat(e.lngLat)
          .setHTML(`<table>${tableHTML}</table>`)
          .setMaxWidth("300px")
          .addTo(map);
      });

      const outsideAreaList = await fetchCSV('outside_area_files.csv');
      const outsideAreaListFiltered = filterOutSideArea(outsideAreaList, defaultSliderValue);
      setOutSideAreaCount(outsideAreaListFiltered);

      filterBy(defaultSliderValue, data);
      downloadCSV(convertArrayOfObjectsToCSV(outsideAreaListFiltered), defaultSliderValue)


      document.getElementById("slider").addEventListener("input", (e) => {
        const outSideRate = parseInt(e.target.value, 10);
        filterBy(outSideRate, data);

        const outsideAreaListFiltered = filterOutSideArea(outsideAreaList, outSideRate);

        setOutSideAreaCount(outsideAreaListFiltered, outSideRate);
        downloadCSV(convertArrayOfObjectsToCSV(outsideAreaListFiltered), outSideRate)
      });
    })
  </script>
</body>

</html>